From ac0130907b8a88cca3c4d8eb590f3b4aa33133d8 Mon Sep 17 00:00:00 2001
From: Doug Flick <dougflick@microsoft.com>
Date: Fri, 15 Dec 2023 13:31:38 -0800
Subject: [PATCH 04/12] SECURITY PATCH TCBZ4534 - CVE-2023-45229 - Host Based
 Unit Test

---
 .../GoogleTest/Dhcp6DxeGoogleTest.cpp         |  54 +-
 .../GoogleTest/Dhcp6DxeGoogleTest.inf         |  86 +--
 .../Dhcp6Dxe/GoogleTest/Dhcp6IoGoogleTest.cpp | 631 ++++++++++++++----
 .../Dhcp6Dxe/GoogleTest/Dhcp6IoGoogleTest.h   |  58 ++
 NetworkPkg/Test/NetworkPkgHostTest.dsc        | 204 +++---
 5 files changed, 726 insertions(+), 307 deletions(-)
 create mode 100644 NetworkPkg/Dhcp6Dxe/GoogleTest/Dhcp6IoGoogleTest.h

diff --git a/NetworkPkg/Dhcp6Dxe/GoogleTest/Dhcp6DxeGoogleTest.cpp b/NetworkPkg/Dhcp6Dxe/GoogleTest/Dhcp6DxeGoogleTest.cpp
index b1fe72e195..36fd708cfc 100644
--- a/NetworkPkg/Dhcp6Dxe/GoogleTest/Dhcp6DxeGoogleTest.cpp
+++ b/NetworkPkg/Dhcp6Dxe/GoogleTest/Dhcp6DxeGoogleTest.cpp
@@ -1,27 +1,27 @@
-/** @file
-  Acts as the main entry point for the tests for the Dhcp6Dxe module.
-
-  Copyright (c) Microsoft Corporation
-  SPDX-License-Identifier: BSD-2-Clause-Patent
-**/
-#include <gtest/gtest.h>
-
-////////////////////////////////////////////////////////////////////////////////
-// Add test files here
-// Google Test will only pick up the tests from the files that are included
-// here.
-////////////////////////////////////////////////////////////////////////////////
-#include "Dhcp6IoGoogleTest.cpp"
-
-////////////////////////////////////////////////////////////////////////////////
-// Run the tests
-////////////////////////////////////////////////////////////////////////////////
-int
-main (
-  int   argc,
-  char  *argv[]
-  )
-{
-  testing::InitGoogleTest (&argc, argv);
-  return RUN_ALL_TESTS ();
-}
+/** @file
+  Acts as the main entry point for the tests for the Dhcp6Dxe module.
+
+  Copyright (c) Microsoft Corporation
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+**/
+#include <gtest/gtest.h>
+
+////////////////////////////////////////////////////////////////////////////////
+// Add test files here
+// Google Test will only pick up the tests from the files that are included
+// here.
+////////////////////////////////////////////////////////////////////////////////
+#include "Dhcp6IoGoogleTest.cpp"
+
+////////////////////////////////////////////////////////////////////////////////
+// Run the tests
+////////////////////////////////////////////////////////////////////////////////
+int
+main (
+  int   argc,
+  char  *argv[]
+  )
+{
+  testing::InitGoogleTest (&argc, argv);
+  return RUN_ALL_TESTS ();
+}
diff --git a/NetworkPkg/Dhcp6Dxe/GoogleTest/Dhcp6DxeGoogleTest.inf b/NetworkPkg/Dhcp6Dxe/GoogleTest/Dhcp6DxeGoogleTest.inf
index c7ec42b322..b74497b6b3 100644
--- a/NetworkPkg/Dhcp6Dxe/GoogleTest/Dhcp6DxeGoogleTest.inf
+++ b/NetworkPkg/Dhcp6Dxe/GoogleTest/Dhcp6DxeGoogleTest.inf
@@ -1,44 +1,44 @@
-## @file
-# Unit test suite for the Dhcp6Dxe using Google Test
-#
-# Copyright (c) Microsoft Corporation.<BR>
-# SPDX-License-Identifier: BSD-2-Clause-Patent
-##
-[Defines]
-  INF_VERSION         = 0x00010017
-  BASE_NAME           = Dhcp6DxeGoogleTest
-  FILE_GUID           = 1D2A4C65-38C8-4C2F-BB60-B5FA49625AA9
-  VERSION_STRING      = 1.0
-  MODULE_TYPE         = HOST_APPLICATION
-#
-# The following information is for reference only and not required by the build tools.
-#
-#  VALID_ARCHITECTURES           = IA32 X64 AARCH64
-#
-[Sources]
-  Dhcp6DxeGoogleTest.cpp
-  Dhcp6IoGoogleTest.cpp
-  ../Dhcp6Io.c
-  ../Dhcp6Utility.c
-
-
-[Packages]
-  MdePkg/MdePkg.dec
-  MdeModulePkg/MdeModulePkg.dec
-  UnitTestFrameworkPkg/UnitTestFrameworkPkg.dec
-  NetworkPkg/NetworkPkg.dec
-
-[LibraryClasses]
-  GoogleTestLib
-  DebugLib
-  NetLib
-  PcdLib
-
-[Protocols]
-  gEfiDhcp6ServiceBindingProtocolGuid
-
-[Pcd]
-  gEfiNetworkPkgTokenSpaceGuid.PcdDhcp6UidType
-
-[Guids]
+## @file
+# Unit test suite for the Dhcp6Dxe using Google Test
+#
+# Copyright (c) Microsoft Corporation.<BR>
+# SPDX-License-Identifier: BSD-2-Clause-Patent
+##
+[Defines]
+  INF_VERSION         = 0x00010017
+  BASE_NAME           = Dhcp6DxeGoogleTest
+  FILE_GUID           = 1D2A4C65-38C8-4C2F-BB60-B5FA49625AA9
+  VERSION_STRING      = 1.0
+  MODULE_TYPE         = HOST_APPLICATION
+#
+# The following information is for reference only and not required by the build tools.
+#
+#  VALID_ARCHITECTURES           = IA32 X64 AARCH64
+#
+[Sources]
+  Dhcp6DxeGoogleTest.cpp
+  Dhcp6IoGoogleTest.cpp
+  ../Dhcp6Io.c
+  ../Dhcp6Utility.c
+
+
+[Packages]
+  MdePkg/MdePkg.dec
+  MdeModulePkg/MdeModulePkg.dec
+  UnitTestFrameworkPkg/UnitTestFrameworkPkg.dec
+  NetworkPkg/NetworkPkg.dec
+
+[LibraryClasses]
+  GoogleTestLib
+  DebugLib
+  NetLib
+  PcdLib
+
+[Protocols]
+  gEfiDhcp6ServiceBindingProtocolGuid
+
+[Pcd]
+  gEfiNetworkPkgTokenSpaceGuid.PcdDhcp6UidType
+
+[Guids]
   gZeroGuid  
\ No newline at end of file
diff --git a/NetworkPkg/Dhcp6Dxe/GoogleTest/Dhcp6IoGoogleTest.cpp b/NetworkPkg/Dhcp6Dxe/GoogleTest/Dhcp6IoGoogleTest.cpp
index dad6a42b12..31e848543d 100644
--- a/NetworkPkg/Dhcp6Dxe/GoogleTest/Dhcp6IoGoogleTest.cpp
+++ b/NetworkPkg/Dhcp6Dxe/GoogleTest/Dhcp6IoGoogleTest.cpp
@@ -7,12 +7,13 @@
 #include <gtest/gtest.h>
 
 extern "C" {
-  #include <Uefi.h>
-  #include <Library/BaseLib.h>
-  #include <Library/DebugLib.h>
-  #include <Library/BaseMemoryLib.h>
-  #include "../Dhcp6Impl.h"
-  #include "../Dhcp6Utility.h"
+#include <Uefi.h>
+#include <Library/BaseLib.h>
+#include <Library/DebugLib.h>
+#include <Library/BaseMemoryLib.h>
+#include "../Dhcp6Impl.h"
+#include "../Dhcp6Utility.h"
+#include "Dhcp6IoGoogleTest.h"
 }
 
 ////////////////////////////////////////////////////////////////////////
@@ -21,7 +22,35 @@ extern "C" {
 
 #define DHCP6_PACKET_MAX_LEN  1500
 
+// This definition is used by this test but is also required to compile
+// by Dhcp6Io.c
+#define DHCPV6_OPTION_IA_NA  3
+#define DHCPV6_OPTION_IA_TA  4
+
+#define SEARCH_PATTERN      0xDEADC0DE
+#define SEARCH_PATTERN_LEN  sizeof(SEARCH_PATTERN)
+
 ////////////////////////////////////////////////////////////////////////
+// Test structures for IA_NA and IA_TA options
+////////////////////////////////////////////////////////////////////////
+typedef struct {
+  UINT16    Code;
+  UINT16    Len;
+  UINT32    IAID;
+} DHCPv6_OPTION;
+
+typedef struct {
+  DHCPv6_OPTION    Header;
+  UINT32           T1;
+  UINT32           T2;
+  UINT8            InnerOptions[0];
+} DHCPv6_OPTION_IA_NA;
+
+typedef struct {
+  DHCPv6_OPTION    Header;
+  UINT8            InnerOptions[0];
+} DHCPv6_OPTION_IA_TA;
+
 ////////////////////////////////////////////////////////////////////////
 // Symbol Definitions
 // These functions are not directly under test - but required to compile
@@ -65,33 +94,33 @@ UdpIoRecvDatagram (
 
 class Dhcp6AppendOptionTest : public ::testing::Test {
 public:
-  UINT8 *Buffer = NULL;
-  EFI_DHCP6_PACKET *Packet;
+UINT8 *Buffer = NULL;
+EFI_DHCP6_PACKET *Packet;
 
 protected:
-  // Add any setup code if needed
-  virtual void
-  SetUp (
-    )
-  {
-    // Initialize any resources or variables
-    Buffer = (UINT8 *)AllocateZeroPool (DHCP6_PACKET_MAX_LEN);
-    ASSERT_NE (Buffer, (UINT8 *)NULL);
-
-    Packet       = (EFI_DHCP6_PACKET *)Buffer;
-    Packet->Size = DHCP6_PACKET_MAX_LEN;
-  }
+// Add any setup code if needed
+virtual void
+SetUp (
+  )
+{
+  // Initialize any resources or variables
+  Buffer = (UINT8 *)AllocateZeroPool (DHCP6_PACKET_MAX_LEN);
+  ASSERT_NE (Buffer, (UINT8 *)NULL);
+
+  Packet       = (EFI_DHCP6_PACKET *)Buffer;
+  Packet->Size = DHCP6_PACKET_MAX_LEN;
+}
 
-  // Add any cleanup code if needed
-  virtual void
-  TearDown (
-    )
-  {
-    // Clean up any resources or variables
-    if (Buffer != NULL) {
-      FreePool (Buffer);
-    }
+// Add any cleanup code if needed
+virtual void
+TearDown (
+  )
+{
+  // Clean up any resources or variables
+  if (Buffer != NULL) {
+    FreePool (Buffer);
   }
+}
 };
 
 // Test Description:
@@ -109,12 +138,12 @@ TEST_F (Dhcp6AppendOptionTest, InvalidDataExpectBufferTooSmall) {
   Cursor = Dhcp6AppendOptionTest::Packet->Dhcp6.Option;
 
   Status = Dhcp6AppendOption (
-             Dhcp6AppendOptionTest::Packet,
-             &Cursor,
-             HTONS (Dhcp6OptServerId),
-             UntrustedDuid->Length,
-             UntrustedDuid->Duid
-             );
+                              Dhcp6AppendOptionTest::Packet,
+                              &Cursor,
+                              HTONS (Dhcp6OptServerId),
+                              UntrustedDuid->Length,
+                              UntrustedDuid->Duid
+                              );
 
   ASSERT_EQ (Status, EFI_BUFFER_TOO_SMALL);
 }
@@ -141,12 +170,12 @@ TEST_F (Dhcp6AppendOptionTest, ValidDataExpectSuccess) {
   Cursor = Dhcp6AppendOptionTest::Packet->Dhcp6.Option;
 
   Status = Dhcp6AppendOption (
-             Dhcp6AppendOptionTest::Packet,
-             &Cursor,
-             HTONS (Dhcp6OptServerId),
-             UntrustedDuid->Length,
-             UntrustedDuid->Duid
-             );
+                              Dhcp6AppendOptionTest::Packet,
+                              &Cursor,
+                              HTONS (Dhcp6OptServerId),
+                              UntrustedDuid->Length,
+                              UntrustedDuid->Duid
+                              );
 
   ASSERT_EQ (Status, EFI_SUCCESS);
 
@@ -163,34 +192,34 @@ TEST_F (Dhcp6AppendOptionTest, ValidDataExpectSuccess) {
 
 class Dhcp6AppendETOptionTest : public ::testing::Test {
 public:
-  UINT8 *Buffer = NULL;
-  EFI_DHCP6_PACKET *Packet;
+UINT8 *Buffer = NULL;
+EFI_DHCP6_PACKET *Packet;
 
 protected:
-  // Add any setup code if needed
-  virtual void
-  SetUp (
-    )
-  {
-    // Initialize any resources or variables
-    Buffer = (UINT8 *)AllocateZeroPool (DHCP6_PACKET_MAX_LEN);
-    ASSERT_NE (Buffer, (UINT8 *)NULL);
-
-    Packet         = (EFI_DHCP6_PACKET *)Buffer;
-    Packet->Size   = DHCP6_PACKET_MAX_LEN;
-    Packet->Length = sizeof (EFI_DHCP6_HEADER);
-  }
+// Add any setup code if needed
+virtual void
+SetUp (
+  )
+{
+  // Initialize any resources or variables
+  Buffer = (UINT8 *)AllocateZeroPool (DHCP6_PACKET_MAX_LEN);
+  ASSERT_NE (Buffer, (UINT8 *)NULL);
+
+  Packet         = (EFI_DHCP6_PACKET *)Buffer;
+  Packet->Size   = DHCP6_PACKET_MAX_LEN;
+  Packet->Length = sizeof (EFI_DHCP6_HEADER);
+}
 
-  // Add any cleanup code if needed
-  virtual void
-  TearDown (
-    )
-  {
-    // Clean up any resources or variables
-    if (Buffer != NULL) {
-      FreePool (Buffer);
-    }
+// Add any cleanup code if needed
+virtual void
+TearDown (
+  )
+{
+  // Clean up any resources or variables
+  if (Buffer != NULL) {
+    FreePool (Buffer);
   }
+}
 };
 
 // Test Description:
@@ -208,11 +237,11 @@ TEST_F (Dhcp6AppendETOptionTest, InvalidDataExpectBufferTooSmall) {
   Packet->Length = Packet->Size - 2;
 
   Status = Dhcp6AppendETOption (
-             Dhcp6AppendETOptionTest::Packet,
-             &Cursor,
-             &Instance, // Instance is not used in this function
-             &ElapsedTime
-             );
+                                Dhcp6AppendETOptionTest::Packet,
+                                &Cursor,
+                                &Instance, // Instance is not used in this function
+                                &ElapsedTime
+                                );
 
   // verify that we error out because the packet is too small for the option header
   ASSERT_EQ (Status, EFI_BUFFER_TOO_SMALL);
@@ -238,11 +267,11 @@ TEST_F (Dhcp6AppendETOptionTest, ValidDataExpectSuccess) {
   OriginalLength = Packet->Length;
 
   Status = Dhcp6AppendETOption (
-             Dhcp6AppendETOptionTest::Packet,
-             &Cursor,
-             &Instance, // Instance is not used in this function
-             &ElapsedTime
-             );
+                                Dhcp6AppendETOptionTest::Packet,
+                                &Cursor,
+                                &Instance, // Instance is not used in this function
+                                &ElapsedTime
+                                );
 
   // verify that the status is EFI_SUCCESS
   ASSERT_EQ (Status, EFI_SUCCESS);
@@ -260,46 +289,46 @@ TEST_F (Dhcp6AppendETOptionTest, ValidDataExpectSuccess) {
 
 class Dhcp6AppendIaOptionTest : public ::testing::Test {
 public:
-  UINT8 *Buffer = NULL;
-  EFI_DHCP6_PACKET *Packet;
-  EFI_DHCP6_IA *Ia;
+UINT8 *Buffer = NULL;
+EFI_DHCP6_PACKET *Packet;
+EFI_DHCP6_IA *Ia;
 
 protected:
-  // Add any setup code if needed
-  virtual void
-  SetUp (
-    )
-  {
-    // Initialize any resources or variables
-    Buffer = (UINT8 *)AllocateZeroPool (DHCP6_PACKET_MAX_LEN);
-    ASSERT_NE (Buffer, (UINT8 *)NULL);
+// Add any setup code if needed
+virtual void
+SetUp (
+  )
+{
+  // Initialize any resources or variables
+  Buffer = (UINT8 *)AllocateZeroPool (DHCP6_PACKET_MAX_LEN);
+  ASSERT_NE (Buffer, (UINT8 *)NULL);
+
+  Packet       = (EFI_DHCP6_PACKET *)Buffer;
+  Packet->Size = DHCP6_PACKET_MAX_LEN;
 
-    Packet       = (EFI_DHCP6_PACKET *)Buffer;
-    Packet->Size = DHCP6_PACKET_MAX_LEN;
+  Ia = (EFI_DHCP6_IA *)AllocateZeroPool (sizeof (EFI_DHCP6_IA) + sizeof (EFI_DHCP6_IA_ADDRESS) * 2);
+  ASSERT_NE (Ia, (EFI_DHCP6_IA *)NULL);
 
-    Ia = (EFI_DHCP6_IA *)AllocateZeroPool (sizeof (EFI_DHCP6_IA) + sizeof (EFI_DHCP6_IA_ADDRESS) * 2);
-    ASSERT_NE (Ia, (EFI_DHCP6_IA *)NULL);
+  CopyMem (Ia->IaAddress, mAllDhcpRelayAndServersAddress.Addr, sizeof (EFI_IPv6_ADDRESS));
+  CopyMem (Ia->IaAddress + 1, mAllDhcpRelayAndServersAddress.Addr, sizeof (EFI_IPv6_ADDRESS));
 
-    CopyMem (Ia->IaAddress, mAllDhcpRelayAndServersAddress.Addr, sizeof (EFI_IPv6_ADDRESS));
-    CopyMem (Ia->IaAddress + 1, mAllDhcpRelayAndServersAddress.Addr, sizeof (EFI_IPv6_ADDRESS));
+  Ia->IaAddressCount = 2;
+}
 
-    Ia->IaAddressCount = 2;
+// Add any cleanup code if needed
+virtual void
+TearDown (
+  )
+{
+  // Clean up any resources or variables
+  if (Buffer != NULL) {
+    FreePool (Buffer);
   }
 
-  // Add any cleanup code if needed
-  virtual void
-  TearDown (
-    )
-  {
-    // Clean up any resources or variables
-    if (Buffer != NULL) {
-      FreePool (Buffer);
-    }
-
-    if (Ia != NULL) {
-      FreePool (Ia);
-    }
+  if (Ia != NULL) {
+    FreePool (Ia);
   }
+}
 };
 
 // Test Description:
@@ -317,13 +346,13 @@ TEST_F (Dhcp6AppendIaOptionTest, IaNaInvalidDataExpectBufferTooSmall) {
   Cursor = Dhcp6AppendIaOptionTest::Packet->Dhcp6.Option;
 
   Status = Dhcp6AppendIaOption (
-             Dhcp6AppendIaOptionTest::Packet,
-             &Cursor,
-             Ia,
-             0x12345678,
-             0x11111111,
-             Dhcp6OptIana
-             );
+                                Dhcp6AppendIaOptionTest::Packet,
+                                &Cursor,
+                                Ia,
+                                0x12345678,
+                                0x11111111,
+                                Dhcp6OptIana
+                                );
 
   // verify that we error out because the packet is too small for the option header
   ASSERT_EQ (Status, EFI_BUFFER_TOO_SMALL);
@@ -348,13 +377,13 @@ TEST_F (Dhcp6AppendIaOptionTest, IaTaInvalidDataExpectBufferTooSmall) {
   Cursor = Dhcp6AppendIaOptionTest::Packet->Dhcp6.Option;
 
   Status = Dhcp6AppendIaOption (
-             Dhcp6AppendIaOptionTest::Packet,
-             &Cursor,
-             Ia,
-             0,
-             0,
-             Dhcp6OptIata
-             );
+                                Dhcp6AppendIaOptionTest::Packet,
+                                &Cursor,
+                                Ia,
+                                0,
+                                0,
+                                Dhcp6OptIata
+                                );
 
   // verify that we error out because the packet is too small for the option header
   ASSERT_EQ (Status, EFI_BUFFER_TOO_SMALL);
@@ -406,13 +435,13 @@ TEST_F (Dhcp6AppendIaOptionTest, IaNaValidDataExpectSuccess) {
   Ia->Descriptor.IaId = 0x12345678;
 
   Status = Dhcp6AppendIaOption (
-             Dhcp6AppendIaOptionTest::Packet,
-             &Cursor,
-             Ia,
-             0x12345678,
-             0x12345678,
-             Dhcp6OptIana
-             );
+                                Dhcp6AppendIaOptionTest::Packet,
+                                &Cursor,
+                                Ia,
+                                0x12345678,
+                                0x12345678,
+                                Dhcp6OptIana
+                                );
 
   // verify that the pointer to cursor moved by the expected amount
   ASSERT_EQ (Cursor, (UINT8 *)Dhcp6AppendIaOptionTest::Packet->Dhcp6.Option + ExpectedSize);
@@ -450,7 +479,7 @@ TEST_F (Dhcp6AppendIaOptionTest, IaTaValidDataExpectSuccess) {
   //
   ExpectedSize += (4 + sizeof (EFI_DHCP6_IA_ADDRESS)) * 2;
 
-  Cursor      = Dhcp6AppendIaOptionTest::Packet->Dhcp6.Option;
+  Cursor = Dhcp6AppendIaOptionTest::Packet->Dhcp6.Option;
 
   Packet->Length = sizeof (EFI_DHCP6_HEADER);
   OriginalLength = Packet->Length;
@@ -459,13 +488,13 @@ TEST_F (Dhcp6AppendIaOptionTest, IaTaValidDataExpectSuccess) {
   Ia->Descriptor.IaId = 0x12345678;
 
   Status = Dhcp6AppendIaOption (
-             Dhcp6AppendIaOptionTest::Packet,
-             &Cursor,
-             Ia,
-             0,
-             0,
-             Dhcp6OptIata
-             );
+                                Dhcp6AppendIaOptionTest::Packet,
+                                &Cursor,
+                                Ia,
+                                0,
+                                0,
+                                Dhcp6OptIata
+                                );
 
   // verify that the pointer to cursor moved by the expected amount
   ASSERT_EQ (Cursor, (UINT8 *)Dhcp6AppendIaOptionTest::Packet->Dhcp6.Option + ExpectedSize);
@@ -476,3 +505,335 @@ TEST_F (Dhcp6AppendIaOptionTest, IaTaValidDataExpectSuccess) {
   // verify that the status is EFI_SUCCESS
   ASSERT_EQ (Status, EFI_SUCCESS);
 }
+
+////////////////////////////////////////////////////////////////////////
+// Dhcp6SeekInnerOptionSafe Tests
+////////////////////////////////////////////////////////////////////////
+
+// Define a fixture for your tests if needed
+class Dhcp6SeekInnerOptionSafeTest : public ::testing::Test {
+protected:
+// Add any setup code if needed
+virtual void
+SetUp (
+  )
+{
+  // Initialize any resources or variables
+}
+
+// Add any cleanup code if needed
+virtual void
+TearDown (
+  )
+{
+  // Clean up any resources or variables
+}
+};
+
+// Test Description:
+// This test verifies that Dhcp6SeekInnerOptionSafe returns EFI_SUCCESS when the IANA option is found.
+TEST_F (Dhcp6SeekInnerOptionSafeTest, IANAValidOptionExpectSuccess) {
+  EFI_STATUS           Result;
+  UINT8                Option[sizeof (DHCPv6_OPTION_IA_NA) + SEARCH_PATTERN_LEN] = { 0 };
+  UINT32               OptionLength                                              = sizeof (Option);
+  DHCPv6_OPTION_IA_NA  *OptionPtr                                                = (DHCPv6_OPTION_IA_NA *)Option;
+  UINT32               SearchPattern                                             = SEARCH_PATTERN;
+
+  UINTN   SearchPatternLength = SEARCH_PATTERN_LEN;
+  UINT8   *InnerOptionPtr     = NULL;
+  UINT16  InnerOptionLength   = 0;
+
+  OptionPtr->Header.Code = Dhcp6OptIana;
+  OptionPtr->Header.Len  = HTONS (4 + 12); // Valid length has to be more than 12
+  OptionPtr->Header.IAID = 0x12345678;
+  OptionPtr->T1          = 0x11111111;
+  OptionPtr->T2          = 0x22222222;
+  CopyMem (OptionPtr->InnerOptions, &SearchPattern, SearchPatternLength);
+
+  Result = Dhcp6SeekInnerOptionSafe (
+                                     Dhcp6OptIana,
+                                     Option,
+                                     OptionLength,
+                                     &InnerOptionPtr,
+                                     &InnerOptionLength
+                                     );
+  ASSERT_EQ (Result, EFI_SUCCESS);
+  ASSERT_EQ (InnerOptionLength, 4);
+  ASSERT_EQ (CompareMem (InnerOptionPtr, &SearchPattern, SearchPatternLength), 0);
+}
+
+// Test Description:
+// This test verifies that Dhcp6SeekInnerOptionSafe returns EFI_DEIVCE_ERROR when the IANA option size is invalid.
+TEST_F (Dhcp6SeekInnerOptionSafeTest, IANAInvalidSizeExpectFail) {
+  // Lets add an inner option of bytes we expect to find
+  EFI_STATUS           Status;
+  UINT8                Option[sizeof (DHCPv6_OPTION_IA_NA) + SEARCH_PATTERN_LEN] = { 0 };
+  UINT32               OptionLength                                              = sizeof (Option);
+  DHCPv6_OPTION_IA_NA  *OptionPtr                                                = (DHCPv6_OPTION_IA_NA *)Option;
+  UINT32               SearchPattern                                             = SEARCH_PATTERN;
+
+  UINTN   SearchPatternLength = SEARCH_PATTERN_LEN;
+  UINT8   *InnerOptionPtr     = NULL;
+  UINT16  InnerOptionLength   = 0;
+
+  OptionPtr->Header.Code = Dhcp6OptIana;
+  OptionPtr->Header.Len  = HTONS (4); // Set the length to lower than expected (12)
+  OptionPtr->Header.IAID = 0x12345678;
+  OptionPtr->T1          = 0x11111111;
+  OptionPtr->T2          = 0x22222222;
+  CopyMem (OptionPtr->InnerOptions, &SearchPattern, SearchPatternLength);
+
+  // Set the InnerOptionLength to be less than the size of the option
+  Status = Dhcp6SeekInnerOptionSafe (
+                                     Dhcp6OptIana,
+                                     Option,
+                                     OptionLength,
+                                     &InnerOptionPtr,
+                                     &InnerOptionLength
+                                     );
+  ASSERT_EQ (Status, EFI_DEVICE_ERROR);
+
+  // Now set the OptionLength to be less than the size of the option
+  OptionLength = sizeof (DHCPv6_OPTION_IA_NA) - 1;
+  Status       = Dhcp6SeekInnerOptionSafe (
+                                           Dhcp6OptIana,
+                                           Option,
+                                           OptionLength,
+                                           &InnerOptionPtr,
+                                           &InnerOptionLength
+                                           );
+  ASSERT_EQ (Status, EFI_DEVICE_ERROR);
+}
+
+// Test Description:
+// This test verifies that Dhcp6SeekInnerOptionSafe returns EFI_SUCCESS when the IATA option is found
+TEST_F (Dhcp6SeekInnerOptionSafeTest, IATAValidOptionExpectSuccess) {
+  // Lets add an inner option of bytes we expect to find
+  EFI_STATUS           Status;
+  UINT8                Option[sizeof (DHCPv6_OPTION_IA_TA) + SEARCH_PATTERN_LEN] = { 0 };
+  UINT32               OptionLength                                              = sizeof (Option);
+  DHCPv6_OPTION_IA_TA  *OptionPtr                                                = (DHCPv6_OPTION_IA_TA *)Option;
+  UINT32               SearchPattern                                             = SEARCH_PATTERN;
+
+  UINTN   SearchPatternLength = SEARCH_PATTERN_LEN;
+  UINT8   *InnerOptionPtr     = NULL;
+  UINT16  InnerOptionLength   = 0;
+
+  OptionPtr->Header.Code = Dhcp6OptIata;
+  OptionPtr->Header.Len  = HTONS (4 + 4); // Valid length has to be more than 4
+  OptionPtr->Header.IAID = 0x12345678;
+  CopyMem (OptionPtr->InnerOptions, &SearchPattern, SearchPatternLength);
+
+  Status = Dhcp6SeekInnerOptionSafe (
+                                     Dhcp6OptIata,
+                                     Option,
+                                     OptionLength,
+                                     &InnerOptionPtr,
+                                     &InnerOptionLength
+                                     );
+  ASSERT_EQ (Status, EFI_SUCCESS);
+  ASSERT_EQ (InnerOptionLength, 4);
+  ASSERT_EQ (CompareMem (InnerOptionPtr, &SearchPattern, SearchPatternLength), 0);
+}
+
+// Test Description:
+// This test verifies that Dhcp6SeekInnerOptionSafe returns EFI_SUCCESS when the IATA option size is invalid.
+TEST_F (Dhcp6SeekInnerOptionSafeTest, IATAInvalidSizeExpectFail) {
+  // Lets add an inner option of bytes we expect to find
+  EFI_STATUS           Status;
+  UINT8                Option[sizeof (DHCPv6_OPTION_IA_TA) + SEARCH_PATTERN_LEN] = { 0 };
+  UINT32               OptionLength                                              = sizeof (Option);
+  DHCPv6_OPTION_IA_TA  *OptionPtr                                                = (DHCPv6_OPTION_IA_TA *)Option;
+  UINT32               SearchPattern                                             = SEARCH_PATTERN;
+
+  UINTN   SearchPatternLength = SEARCH_PATTERN_LEN;
+  UINT8   *InnerOptionPtr     = NULL;
+  UINT16  InnerOptionLength   = 0;
+
+  OptionPtr->Header.Code = Dhcp6OptIata;
+  OptionPtr->Header.Len  = HTONS (2); // Set the length to lower than expected (4)
+  OptionPtr->Header.IAID = 0x12345678;
+  CopyMem (OptionPtr->InnerOptions, &SearchPattern, SearchPatternLength);
+
+  Status = Dhcp6SeekInnerOptionSafe (
+                                     Dhcp6OptIata,
+                                     Option,
+                                     OptionLength,
+                                     &InnerOptionPtr,
+                                     &InnerOptionLength
+                                     );
+  ASSERT_EQ (Status, EFI_DEVICE_ERROR);
+
+  // Now lets try modifying the OptionLength to be less than the size of the option
+  OptionLength = sizeof (DHCPv6_OPTION_IA_TA) - 1;
+  Status       = Dhcp6SeekInnerOptionSafe (
+                                           Dhcp6OptIata,
+                                           Option,
+                                           OptionLength,
+                                           &InnerOptionPtr,
+                                           &InnerOptionLength
+                                           );
+  ASSERT_EQ (Status, EFI_DEVICE_ERROR);
+}
+
+// Test Description:
+// This test verifies that any other Option Type fails
+TEST_F (Dhcp6SeekInnerOptionSafeTest, InvalidOption) {
+  // Lets add an inner option of bytes we expect to find
+  EFI_STATUS           Result;
+  UINT8                Option[sizeof (DHCPv6_OPTION_IA_TA) + SEARCH_PATTERN_LEN] = { 0 };
+  UINT32               OptionLength                                              = sizeof (Option);
+  DHCPv6_OPTION_IA_TA  *OptionPtr                                                = (DHCPv6_OPTION_IA_TA *)Option;
+  UINT32               SearchPattern                                             = SEARCH_PATTERN;
+
+  UINTN   SearchPatternLength = SEARCH_PATTERN_LEN;
+  UINT8   *InnerOptionPtr     = NULL;
+  UINT16  InnerOptionLength   = 0;
+
+  OptionPtr->Header.Code = 0xC0DE;
+  OptionPtr->Header.Len  = HTONS (2); // Set the length to lower than expected (4)
+  OptionPtr->Header.IAID = 0x12345678;
+  CopyMem (OptionPtr->InnerOptions, &SearchPattern, SearchPatternLength);
+
+  Result = Dhcp6SeekInnerOptionSafe (0xC0DE, Option, OptionLength, &InnerOptionPtr, &InnerOptionLength);
+  ASSERT_EQ (Result, EFI_DEVICE_ERROR);
+}
+
+////////////////////////////////////////////////////////////////////////
+// Dhcp6SeekStsOption Tests
+////////////////////////////////////////////////////////////////////////
+
+#define PACKET_SIZE  (1500)
+
+class Dhcp6SeekStsOptionTest : public ::testing::Test {
+public:
+DHCP6_INSTANCE Instance      = { 0 };
+EFI_DHCP6_PACKET *Packet     = NULL;
+EFI_DHCP6_CONFIG_DATA Config = { 0 };
+
+protected:
+// Add any setup code if needed
+virtual void
+SetUp (
+  )
+{
+  // Allocate a packet
+  Packet = (EFI_DHCP6_PACKET *)AllocateZeroPool (PACKET_SIZE);
+  ASSERT_NE (Packet, nullptr);
+
+  // Initialize the packet
+  Packet->Size = PACKET_SIZE;
+
+  Instance.Config = &Config;
+}
+
+// Add any cleanup code if needed
+virtual void
+TearDown (
+  )
+{
+  // Clean up any resources or variables
+  FreePool (Packet);
+}
+};
+
+// Test Description:
+// This test verifies that Dhcp6SeekStsOption returns EFI_DEVICE_ERROR when the option is invalid
+// This verifies that the calling function is working as expected
+TEST_F (Dhcp6SeekStsOptionTest, SeekIATAOptionExpectFail) {
+  EFI_STATUS    Status;
+  UINT8         *Option             = NULL;
+  UINT32        SearchPattern       = SEARCH_PATTERN;
+  UINT16        SearchPatternLength = SEARCH_PATTERN_LEN;
+  UINT16        *Len                = NULL;
+  EFI_DHCP6_IA  Ia                  = { 0 };
+
+  Ia.Descriptor.Type                = DHCPV6_OPTION_IA_TA;
+  Ia.IaAddressCount                 = 1;
+  Ia.IaAddress[0].PreferredLifetime = 0xDEADBEEF;
+  Ia.IaAddress[0].ValidLifetime     = 0xDEADAAAA;
+  Ia.IaAddress[0].IpAddress         = mAllDhcpRelayAndServersAddress;
+
+  Packet->Length = sizeof (EFI_DHCP6_HEADER);
+
+  Option = Dhcp6SeekStsOptionTest::Packet->Dhcp6.Option;
+
+  // Let's append the option to the packet
+  Status = Dhcp6AppendOption (
+             Dhcp6SeekStsOptionTest::Packet,
+             &Option,
+             Dhcp6OptStatusCode,
+             SearchPatternLength,
+             (UINT8 *)&SearchPattern
+             );
+  ASSERT_EQ (Status, EFI_SUCCESS);
+
+  // Inner option length - this will be overwritten later
+  Len = (UINT16 *)(Option + 2);
+
+  // Fill in the inner IA option
+  Status = Dhcp6AppendIaOption (
+             Dhcp6SeekStsOptionTest::Packet,
+             &Option,
+             &Ia,
+             0x12345678,
+             0x11111111,
+             0x22222222
+             );
+  ASSERT_EQ (Status, EFI_SUCCESS);
+
+  // overwrite the len of inner Ia option
+  *Len = HTONS (3);
+
+  Dhcp6SeekStsOptionTest::Instance.Config->IaDescriptor.Type = DHCPV6_OPTION_IA_TA;
+
+  Option = NULL;
+  Status = Dhcp6SeekStsOption (&(Dhcp6SeekStsOptionTest::Instance), Dhcp6SeekStsOptionTest::Packet, &Option);
+
+  ASSERT_EQ (Status, EFI_DEVICE_ERROR);
+}
+
+// Test Description:
+// This test verifies that Dhcp6SeekInnerOptionSafe returns EFI_SUCCESS when the IATA option size is invalid.
+TEST_F (Dhcp6SeekStsOptionTest, SeekIANAOptionExpectSuccess) {
+  EFI_STATUS    Status              = EFI_NOT_FOUND;
+  UINT8         *Option             = NULL;
+  UINT32        SearchPattern       = SEARCH_PATTERN;
+  UINT16        SearchPatternLength = SEARCH_PATTERN_LEN;
+  EFI_DHCP6_IA  Ia                  = { 0 };
+
+  Ia.Descriptor.Type                = DHCPV6_OPTION_IA_NA;
+  Ia.IaAddressCount                 = 1;
+  Ia.IaAddress[0].PreferredLifetime = 0x11111111;
+  Ia.IaAddress[0].ValidLifetime     = 0x22222222;
+  Ia.IaAddress[0].IpAddress         = mAllDhcpRelayAndServersAddress;
+  Packet->Length                    = sizeof (EFI_DHCP6_HEADER);
+
+  Option = Dhcp6SeekStsOptionTest::Packet->Dhcp6.Option;
+
+  Status = Dhcp6AppendOption (
+             Dhcp6SeekStsOptionTest::Packet,
+             &Option,
+             Dhcp6OptStatusCode,
+             SearchPatternLength,
+             (UINT8 *)&SearchPattern
+             );
+  ASSERT_EQ (Status, EFI_SUCCESS);
+
+  Status = Dhcp6AppendIaOption (
+             Dhcp6SeekStsOptionTest::Packet,
+             &Option,
+             &Ia,
+             0x12345678,
+             0x11111111,
+             0x22222222
+             );
+  ASSERT_EQ (Status, EFI_SUCCESS);
+
+  Dhcp6SeekStsOptionTest::Instance.Config->IaDescriptor.Type = DHCPV6_OPTION_IA_NA;
+
+  Option = NULL;
+  Status = Dhcp6SeekStsOption (&(Dhcp6SeekStsOptionTest::Instance), Dhcp6SeekStsOptionTest::Packet, &Option);
+
+  ASSERT_EQ (Status, EFI_SUCCESS);
+}
diff --git a/NetworkPkg/Dhcp6Dxe/GoogleTest/Dhcp6IoGoogleTest.h b/NetworkPkg/Dhcp6Dxe/GoogleTest/Dhcp6IoGoogleTest.h
new file mode 100644
index 0000000000..c5e38daf9c
--- /dev/null
+++ b/NetworkPkg/Dhcp6Dxe/GoogleTest/Dhcp6IoGoogleTest.h
@@ -0,0 +1,58 @@
+/** @file
+  Acts as header for private functions under test in Dhcp6Io.c
+
+  Copyright (c) Microsoft Corporation
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+**/
+
+#ifndef DHCP6_IO_GOOGLE_TEST_H
+#define DHCP6_IO_GOOGLE_TEST_H
+
+////////////////////////////////////////////////////////////////////////////////
+// These are the functions that are being unit tested
+////////////////////////////////////////////////////////////////////////////////
+
+#include <Uefi.h>
+
+/**
+  Seeks the Inner Options from a DHCP6 Option
+
+  @param[in]  IaType          The type of the IA option.
+  @param[in]  Option          The pointer to the DHCP6 Option.
+  @param[in]  OptionLen       The length of the DHCP6 Option.
+  @param[out] IaInnerOpt      The pointer to the IA inner option.
+  @param[out] IaInnerLen      The length of the IA inner option.
+
+  @retval EFI_SUCCESS         Seek the inner option successfully.
+  @retval EFI_DEVICE_ERROR    The OptionLen is invalid.
+*/
+EFI_STATUS
+Dhcp6SeekInnerOptionSafe (
+  UINT16  IaType,
+  UINT8   *Option,
+  UINT32  OptionLen,
+  UINT8   **IaInnerOpt,
+  UINT16  *IaInnerLen
+  );
+
+/**
+  Seek StatusCode Option in package. A Status Code option may appear in the
+  options field of a DHCP message and/or in the options field of another option.
+  See details in section 22.13, RFC3315.
+
+  @param[in]       Instance        The pointer to the Dhcp6 instance.
+  @param[in]       Packet          The pointer to reply messages.
+  @param[out]      Option          The pointer to status code option.
+
+  @retval EFI_SUCCESS              Seek status code option successfully.
+  @retval EFI_DEVICE_ERROR         An unexpected error.
+
+**/
+EFI_STATUS
+Dhcp6SeekStsOption (
+  IN     DHCP6_INSTANCE    *Instance,
+  IN     EFI_DHCP6_PACKET  *Packet,
+  OUT    UINT8             **Option
+  );
+
+#endif // DHCP6_IO_GOOGLE_TEST_H
diff --git a/NetworkPkg/Test/NetworkPkgHostTest.dsc b/NetworkPkg/Test/NetworkPkgHostTest.dsc
index 5befdf7688..f6459b124f 100644
--- a/NetworkPkg/Test/NetworkPkgHostTest.dsc
+++ b/NetworkPkg/Test/NetworkPkgHostTest.dsc
@@ -1,102 +1,102 @@
-## @file
-# NetworkPkgHostTest DSC file used to build host-based unit tests.
-#
-# Copyright (c) Microsoft Corporation.<BR>
-# SPDX-License-Identifier: BSD-2-Clause-Patent
-#
-##
-[Defines]
-  PLATFORM_NAME           = NetworkPkgHostTest
-  PLATFORM_GUID           = 3b68324e-fc07-4d49-9520-9347ede65879
-  PLATFORM_VERSION        = 0.1
-  DSC_SPECIFICATION       = 0x00010005
-  OUTPUT_DIRECTORY        = Build/NetworkPkg/HostTest
-  SUPPORTED_ARCHITECTURES = IA32|X64|AARCH64
-  BUILD_TARGETS           = NOOPT
-  SKUID_IDENTIFIER        = DEFAULT
-  
-!include UnitTestFrameworkPkg/UnitTestFrameworkPkgHost.dsc.inc
-[Packages]
-  MdePkg/MdePkg.dec
-  UnitTestFrameworkPkg/UnitTestFrameworkPkg.dec
-
-[Components]
-  #
-  # Build HOST_APPLICATION that tests NetworkPkg
-  #
-  NetworkPkg/Dhcp6Dxe/GoogleTest/Dhcp6DxeGoogleTest.inf
-
-# Despite these library classes being listed in [LibraryClasses] below, they are not needed for the host-based unit tests.
-[LibraryClasses]
-  NetLib|NetworkPkg/Library/DxeNetLib/DxeNetLib.inf
-  DebugLib|MdePkg/Library/BaseDebugLibNull/BaseDebugLibNull.inf
-  BaseLib|MdePkg/Library/BaseLib/BaseLib.inf
-  BaseMemoryLib|MdePkg/Library/BaseMemoryLib/BaseMemoryLib.inf
-  DevicePathLib|MdePkg/Library/UefiDevicePathLib/UefiDevicePathLib.inf
-  HiiLib|MdeModulePkg/Library/UefiHiiLib/UefiHiiLib.inf
-  MemoryAllocationLib|MdePkg/Library/UefiMemoryAllocationLib/UefiMemoryAllocationLib.inf
-  PcdLib|MdePkg/Library/BasePcdLibNull/BasePcdLibNull.inf
-  PrintLib|MdePkg/Library/BasePrintLib/BasePrintLib.inf
-  UefiDriverEntryPoint|MdePkg/Library/UefiDriverEntryPoint/UefiDriverEntryPoint.inf
-  UefiApplicationEntryPoint|MdePkg/Library/UefiApplicationEntryPoint/UefiApplicationEntryPoint.inf
-  UefiBootServicesTableLib|MdePkg/Library/UefiBootServicesTableLib/UefiBootServicesTableLib.inf
-  UefiLib|MdePkg/Library/UefiLib/UefiLib.inf
-  UefiRuntimeServicesTableLib|MdePkg/Library/UefiRuntimeServicesTableLib/UefiRuntimeServicesTableLib.inf
-  UefiHiiServicesLib|MdeModulePkg/Library/UefiHiiServicesLib/UefiHiiServicesLib.inf
-  UefiBootManagerLib|MdeModulePkg/Library/UefiBootManagerLib/UefiBootManagerLib.inf
-  TimerLib|MdePkg/Library/BaseTimerLibNullTemplate/BaseTimerLibNullTemplate.inf
-  PerformanceLib|MdePkg/Library/BasePerformanceLibNull/BasePerformanceLibNull.inf
-  PeCoffGetEntryPointLib|MdePkg/Library/BasePeCoffGetEntryPointLib/BasePeCoffGetEntryPointLib.inf
-  DxeServicesLib|MdePkg/Library/DxeServicesLib/DxeServicesLib.inf
-  DxeServicesTableLib|MdePkg/Library/DxeServicesTableLib/DxeServicesTableLib.inf
-  SafeIntLib|MdePkg/Library/BaseSafeIntLib/BaseSafeIntLib.inf
-  RngLib|MdePkg/Library/BaseRngLib/BaseRngLib.inf
-  VariablePolicyHelperLib|MdeModulePkg/Library/VariablePolicyHelperLib/VariablePolicyHelperLib.inf
-!ifdef CONTINUOUS_INTEGRATION
-  BaseCryptLib|CryptoPkg/Library/BaseCryptLibNull/BaseCryptLibNull.inf
-  TlsLib|CryptoPkg/Library/TlsLibNull/TlsLibNull.inf
-!else
-  BaseCryptLib|CryptoPkg/Library/BaseCryptLib/BaseCryptLib.inf
-  OpensslLib|CryptoPkg/Library/OpensslLib/OpensslLib.inf
-  TlsLib|CryptoPkg/Library/TlsLib/TlsLib.inf
-!endif
-  DebugPrintErrorLevelLib|MdePkg/Library/BaseDebugPrintErrorLevelLib/BaseDebugPrintErrorLevelLib.inf
-  FileHandleLib|MdePkg/Library/UefiFileHandleLib/UefiFileHandleLib.inf
-  FileExplorerLib|MdeModulePkg/Library/FileExplorerLib/FileExplorerLib.inf
-  SortLib|MdeModulePkg/Library/UefiSortLib/UefiSortLib.inf
-  IntrinsicLib|CryptoPkg/Library/IntrinsicLib/IntrinsicLib.inf
-
-!if $(TOOL_CHAIN_TAG) == VS2019 or $(TOOL_CHAIN_TAG) == VS2022
-[LibraryClasses.X64]
-  # Provide StackCookie support lib so that we can link to /GS exports for VS builds
-  RngLib|MdePkg/Library/BaseRngLib/BaseRngLib.inf
-  NULL|MdePkg/Library/BaseBinSecurityLibRng/BaseBinSecurityLibRng.inf
-!endif
-
-[LibraryClasses.common.UEFI_DRIVER]
-  HobLib|MdePkg/Library/DxeHobLib/DxeHobLib.inf
-  ReportStatusCodeLib|MdeModulePkg/Library/DxeReportStatusCodeLib/DxeReportStatusCodeLib.inf
-  DebugLib|MdePkg/Library/UefiDebugLibConOut/UefiDebugLibConOut.inf
-[LibraryClasses.common.UEFI_APPLICATION]
-  DebugLib|MdePkg/Library/UefiDebugLibStdErr/UefiDebugLibStdErr.inf
-  ShellLib|ShellPkg/Library/UefiShellLib/UefiShellLib.inf
-[LibraryClasses.ARM, LibraryClasses.AARCH64]
-  #
-  # It is not possible to prevent ARM compiler calls to generic intrinsic functions.
-  # This library provides the instrinsic functions generated by a given compiler.
-  # [LibraryClasses.ARM] and NULL mean link this library into all ARM images.
-  #
-  # MU_CHANGE Start
-!if $(TOOL_CHAIN_TAG) != VS2017 and $(TOOL_CHAIN_TAG) != VS2015 and $(TOOL_CHAIN_TAG) != VS2019
-  NULL|ArmPkg/Library/CompilerIntrinsicsLib/CompilerIntrinsicsLib.inf
-!endif
-  # MU_CHANGE End
-  NULL|MdePkg/Library/BaseStackCheckLib/BaseStackCheckLib.inf
-[LibraryClasses.ARM]
-  RngLib|MdePkg/Library/BaseRngLibTimerLib/BaseRngLibTimerLib.inf
-[LibraryClasses.RISCV64]
-  RngLib|MdePkg/Library/BaseRngLibTimerLib/BaseRngLibTimerLib.inf
-  
-[PcdsFixedAtBuild]
-  gEfiMdePkgTokenSpaceGuid.PcdDebugPropertyMask|0x2
-  gEfiNetworkPkgTokenSpaceGuid.PcdDhcp6UidType|0x4
\ No newline at end of file
+## @file
+# NetworkPkgHostTest DSC file used to build host-based unit tests.
+#
+# Copyright (c) Microsoft Corporation.<BR>
+# SPDX-License-Identifier: BSD-2-Clause-Patent
+#
+##
+[Defines]
+  PLATFORM_NAME           = NetworkPkgHostTest
+  PLATFORM_GUID           = 3b68324e-fc07-4d49-9520-9347ede65879
+  PLATFORM_VERSION        = 0.1
+  DSC_SPECIFICATION       = 0x00010005
+  OUTPUT_DIRECTORY        = Build/NetworkPkg/HostTest
+  SUPPORTED_ARCHITECTURES = IA32|X64|AARCH64
+  BUILD_TARGETS           = NOOPT
+  SKUID_IDENTIFIER        = DEFAULT
+  
+!include UnitTestFrameworkPkg/UnitTestFrameworkPkgHost.dsc.inc
+[Packages]
+  MdePkg/MdePkg.dec
+  UnitTestFrameworkPkg/UnitTestFrameworkPkg.dec
+
+[Components]
+  #
+  # Build HOST_APPLICATION that tests NetworkPkg
+  #
+  NetworkPkg/Dhcp6Dxe/GoogleTest/Dhcp6DxeGoogleTest.inf
+
+# Despite these library classes being listed in [LibraryClasses] below, they are not needed for the host-based unit tests.
+[LibraryClasses]
+  NetLib|NetworkPkg/Library/DxeNetLib/DxeNetLib.inf
+  DebugLib|MdePkg/Library/BaseDebugLibNull/BaseDebugLibNull.inf
+  BaseLib|MdePkg/Library/BaseLib/BaseLib.inf
+  BaseMemoryLib|MdePkg/Library/BaseMemoryLib/BaseMemoryLib.inf
+  DevicePathLib|MdePkg/Library/UefiDevicePathLib/UefiDevicePathLib.inf
+  HiiLib|MdeModulePkg/Library/UefiHiiLib/UefiHiiLib.inf
+  MemoryAllocationLib|MdePkg/Library/UefiMemoryAllocationLib/UefiMemoryAllocationLib.inf
+  PcdLib|MdePkg/Library/BasePcdLibNull/BasePcdLibNull.inf
+  PrintLib|MdePkg/Library/BasePrintLib/BasePrintLib.inf
+  UefiDriverEntryPoint|MdePkg/Library/UefiDriverEntryPoint/UefiDriverEntryPoint.inf
+  UefiApplicationEntryPoint|MdePkg/Library/UefiApplicationEntryPoint/UefiApplicationEntryPoint.inf
+  UefiBootServicesTableLib|MdePkg/Library/UefiBootServicesTableLib/UefiBootServicesTableLib.inf
+  UefiLib|MdePkg/Library/UefiLib/UefiLib.inf
+  UefiRuntimeServicesTableLib|MdePkg/Library/UefiRuntimeServicesTableLib/UefiRuntimeServicesTableLib.inf
+  UefiHiiServicesLib|MdeModulePkg/Library/UefiHiiServicesLib/UefiHiiServicesLib.inf
+  UefiBootManagerLib|MdeModulePkg/Library/UefiBootManagerLib/UefiBootManagerLib.inf
+  TimerLib|MdePkg/Library/BaseTimerLibNullTemplate/BaseTimerLibNullTemplate.inf
+  PerformanceLib|MdePkg/Library/BasePerformanceLibNull/BasePerformanceLibNull.inf
+  PeCoffGetEntryPointLib|MdePkg/Library/BasePeCoffGetEntryPointLib/BasePeCoffGetEntryPointLib.inf
+  DxeServicesLib|MdePkg/Library/DxeServicesLib/DxeServicesLib.inf
+  DxeServicesTableLib|MdePkg/Library/DxeServicesTableLib/DxeServicesTableLib.inf
+  SafeIntLib|MdePkg/Library/BaseSafeIntLib/BaseSafeIntLib.inf
+  RngLib|MdePkg/Library/BaseRngLib/BaseRngLib.inf
+  VariablePolicyHelperLib|MdeModulePkg/Library/VariablePolicyHelperLib/VariablePolicyHelperLib.inf
+!ifdef CONTINUOUS_INTEGRATION
+  BaseCryptLib|CryptoPkg/Library/BaseCryptLibNull/BaseCryptLibNull.inf
+  TlsLib|CryptoPkg/Library/TlsLibNull/TlsLibNull.inf
+!else
+  BaseCryptLib|CryptoPkg/Library/BaseCryptLib/BaseCryptLib.inf
+  OpensslLib|CryptoPkg/Library/OpensslLib/OpensslLib.inf
+  TlsLib|CryptoPkg/Library/TlsLib/TlsLib.inf
+!endif
+  DebugPrintErrorLevelLib|MdePkg/Library/BaseDebugPrintErrorLevelLib/BaseDebugPrintErrorLevelLib.inf
+  FileHandleLib|MdePkg/Library/UefiFileHandleLib/UefiFileHandleLib.inf
+  FileExplorerLib|MdeModulePkg/Library/FileExplorerLib/FileExplorerLib.inf
+  SortLib|MdeModulePkg/Library/UefiSortLib/UefiSortLib.inf
+  IntrinsicLib|CryptoPkg/Library/IntrinsicLib/IntrinsicLib.inf
+
+!if $(TOOL_CHAIN_TAG) == VS2019 or $(TOOL_CHAIN_TAG) == VS2022
+[LibraryClasses.X64]
+  # Provide StackCookie support lib so that we can link to /GS exports for VS builds
+  RngLib|MdePkg/Library/BaseRngLib/BaseRngLib.inf
+  NULL|MdePkg/Library/BaseBinSecurityLibRng/BaseBinSecurityLibRng.inf
+!endif
+
+[LibraryClasses.common.UEFI_DRIVER]
+  HobLib|MdePkg/Library/DxeHobLib/DxeHobLib.inf
+  ReportStatusCodeLib|MdeModulePkg/Library/DxeReportStatusCodeLib/DxeReportStatusCodeLib.inf
+  DebugLib|MdePkg/Library/UefiDebugLibConOut/UefiDebugLibConOut.inf
+[LibraryClasses.common.UEFI_APPLICATION]
+  DebugLib|MdePkg/Library/UefiDebugLibStdErr/UefiDebugLibStdErr.inf
+  ShellLib|ShellPkg/Library/UefiShellLib/UefiShellLib.inf
+[LibraryClasses.ARM, LibraryClasses.AARCH64]
+  #
+  # It is not possible to prevent ARM compiler calls to generic intrinsic functions.
+  # This library provides the instrinsic functions generated by a given compiler.
+  # [LibraryClasses.ARM] and NULL mean link this library into all ARM images.
+  #
+  # MU_CHANGE Start
+!if $(TOOL_CHAIN_TAG) != VS2017 and $(TOOL_CHAIN_TAG) != VS2015 and $(TOOL_CHAIN_TAG) != VS2019
+  NULL|ArmPkg/Library/CompilerIntrinsicsLib/CompilerIntrinsicsLib.inf
+!endif
+  # MU_CHANGE End
+  NULL|MdePkg/Library/BaseStackCheckLib/BaseStackCheckLib.inf
+[LibraryClasses.ARM]
+  RngLib|MdePkg/Library/BaseRngLibTimerLib/BaseRngLibTimerLib.inf
+[LibraryClasses.RISCV64]
+  RngLib|MdePkg/Library/BaseRngLibTimerLib/BaseRngLibTimerLib.inf
+  
+[PcdsFixedAtBuild]
+  gEfiMdePkgTokenSpaceGuid.PcdDebugPropertyMask|0x2
+  gEfiNetworkPkgTokenSpaceGuid.PcdDhcp6UidType|0x4
-- 
2.41.0
